import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation 
from matplotlib.widgets import Button
import os
import numpy as np 
from datetime import datetime
from matplotlib.ticker import ScalarFormatter
import math 

# --- CONFIGURATION (Change these file paths as needed) ---
# NOTE: Using absolute paths to prevent File Not Found errors.
# IMPORTANT: Adjust this BASE_PATH to the actual location of your CSV files.
BASE_PATH = "c:/Users/peter_bkbowcp/OneDrive/Desktop/Dashboard Project/" 

GOLD_FILE = BASE_PATH + "Gold Futures Historical Data.csv"
BTC_FILE = BASE_PATH + "Bitcoin Historical Data.csv"

START_DATE = '2011-01-01'
TRADING_DAYS_PER_YEAR = 252

# Animation Configuration
STEP_SIZE = 20 # Days revealed per frame (adjust for speed/smoothness)

# List of common column headers for the closing price
CLOSE_CANDIDATES = ["Close", "Adj Close", "Close*", "Price", "Last", "Close/Last"]

# Global variable to hold the animation object (must be global to prevent garbage collection)
ani = None

# --- Helper function to clean quoted, comma-separated numbers ---
def clean_numeric_series(s):
    """Removes non-numeric characters (quotes, commas) and converts to float."""
    return (s.astype(str)
            .str.replace('"', '', regex=False)
            .str.replace("'", "", regex=False)
            .str.replace(",", "", regex=False)
            .str.strip()
            .replace("", pd.NA) 
            .astype(float)
           )

# --- Helper function to load and clean a single file ---
def load_and_clean(filename, asset_name):
    """Loads a CSV, cleans data, sets Date as index, and converts prices to float."""
    print(f"Loading {asset_name} data from: {filename}")
    if not os.path.exists(filename):
        raise FileNotFoundError(
            f"ERROR: File not found: '{filename}'. "
            f"Please ensure the path and filename are correct."
        )

    df = pd.read_csv(filename, skip_blank_lines=True)
    df.columns = [c.strip() for c in df.columns]

    date_col = next((c for c in df.columns if c.strip().lower() in ["date", "day", "time"]), None)
    if date_col is None:
        raise ValueError(f"No 'Date' column found in {filename}.")
        
    close_col = next(
        (c for c in df.columns for cand in CLOSE_CANDIDATES if c.strip().lower() == cand.strip().lower()), 
        None
    )
    if close_col is None:
        raise ValueError(f"No closing price column found (e.g., Close, Price) in {filename}.")
        
    df["Date"] = pd.to_datetime(
        df[date_col].astype(str).str.replace('"', '').str.strip(), 
        errors='coerce',
        infer_datetime_format=True
    )

    df["Close"] = clean_numeric_series(df[close_col])
    
    df['Daily_Return'] = df['Close'].pct_change()
    
    df = df[["Date", "Close", "Daily_Return"]].dropna(subset=["Date", "Close"]).sort_values("Date")
    df = df.set_index("Date")
    df = df[df.index >= START_DATE]
    
    if not df.empty and df.iloc[0]['Close'] != 0:
        df[f'Index_{asset_name}'] = (df['Close'] / df['Close'].iloc[0]) * 100
    else:
        df[f'Index_{asset_name}'] = 100
    
    return df.rename(columns={'Close': f'Close_{asset_name}', 'Daily_Return': f'Return_{asset_name}'})

# --- Animation/Update Function ---
def animate_frame(i, combined, line_gold, line_btc, ax1_gold, button):
    """
    Updates the data displayed on the plot for each frame using the frame index 'i'.
    This is the core fix to ensure consistent progression.
    """
    
    # Calculate the end index for the current frame: (frame_number + 1) * step_size
    end_index = min((i + 1) * STEP_SIZE, len(combined))

    # Slice the data up to the current frame's end index
    data_slice = combined.iloc[:end_index]

    if data_slice.empty:
        return line_gold, line_btc

    # Update Gold line data
    line_gold.set_data(data_slice.index, data_slice['Close_Gold'])
    # Update BTC line data
    line_btc.set_data(data_slice.index, data_slice['Close_BTC'])

    # Update the title to show the current date of the animation
    current_date = data_slice.index[-1].strftime('%Y-%m-%d')
    ax1_gold.set_title(
        f"Animated Price Growth of Gold and Bitcoin (Data up to: {current_date})",
        fontsize=16,
        fontweight='bold',
        pad=10
    )
    # Print current date to the console for tracking
    print(f"Drawing up to: {current_date}", end='\r')

    # Check if this is the final frame and update the button text
    if end_index == len(combined):
        button.label.set_text('Replay Animation')
        # Ensure the button text updates immediately
        button.ax.figure.canvas.draw_idle() 
    
    # Return the artists (lines) that were modified
    return line_gold, line_btc

# --- Button Callback Function ---
def start_animation_callback(event, combined, fig, ax1_gold, line_gold, line_btc, button):
    """Initializes and starts the FuncAnimation when the button is clicked."""
    global ani
    
    # 1. Stop any previous animation
    if ani:
        ani.event_source.stop()
    
    # 2. Clear the lines to start from scratch (resets the plot to empty lines)
    line_gold.set_data([], [])
    line_btc.set_data([], [])

    # 3. Update button state and title
    button.label.set_text('Animating...')
    button.ax.figure.canvas.draw_idle() # Redraw button immediately

    # Set title back to a neutral starting state
    ax1_gold.set_title(
        f"Animated Price Growth of Gold and Bitcoin (Starting...)",
        fontsize=16,
        fontweight='bold',
        pad=10
    )

    # 4. Calculate number of frames needed
    num_frames = math.ceil(len(combined) / STEP_SIZE)
    
    # 5. Initialize and assign the animation object to the global variable
    ani = animation.FuncAnimation(
        fig,
        animate_frame,
        fargs=(combined, line_gold, line_btc, ax1_gold, button),
        frames=num_frames, # Use the calculated number of frames
        interval=50, # 50 milliseconds between frames
        blit=False, # IMPORTANT: Setting blit to False for reliable title/button updates
        repeat=False
    )
    
    # Ensure the plot redrawing is triggered
    fig.canvas.draw_idle()


# --- Main Plotting Function ---
def plot_gold_btc_dashboard():
    
    try:
        # Load Gold and BTC files
        gold_df = load_and_clean(GOLD_FILE, 'Gold')
        btc_df  = load_and_clean(BTC_FILE, 'BTC')
            
    except Exception as e:
        print(f"An error occurred during file loading: {e}")
        return

    # 1. Merge data
    combined = pd.merge(gold_df[[f'Close_Gold', 'Return_Gold']], 
                        btc_df[[f'Close_BTC', 'Return_BTC']], 
                        left_index=True, right_index=True, how="inner").dropna()
        
    if combined.empty:
        print(f"ERROR: No common dates found across the required files after {START_DATE}.")
        return
        
    # 2. Calculate Statistics
    daily_returns = combined[['Return_Gold', 'Return_BTC']].dropna()
    
    gold_mean = daily_returns["Return_Gold"].mean() * TRADING_DAYS_PER_YEAR * 100
    gold_std  = daily_returns["Return_Gold"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    btc_mean  = daily_returns["Return_BTC"].mean() * TRADING_DAYS_PER_YEAR * 100
    btc_std   = daily_returns["Return_BTC"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    correlation = daily_returns["Return_Gold"].corr(daily_returns["Return_BTC"])
    
    # --- Plotting Setup ---
    plt.style.use('default')
    
    # Create the main axes for the plot
    # The figure size is increased, and the plot area is shifted up to make space for the button
    fig, ax1_gold = plt.subplots(1, 1, figsize=(18, 9)) 
    
    # Adjust subplot position to make room for the button
    fig.subplots_adjust(bottom=0.1)

    # Define colors
    color_gold = '#E69F00' 
    color_btc = '#003366' 

    # --- Initial Static Plot (Shows the complete data) ---
    
    # Plot Gold Price (Orange, Left Axis)
    line_gold, = ax1_gold.plot(
        combined.index, 
        combined['Close_Gold'], 
        label="Gold Price (USD per oz)", 
        color=color_gold, 
        linewidth=2.5
    )
    ax1_gold.set_ylabel("Prices in USD per oz (Gold)", fontsize=14, color=color_gold)
    ax1_gold.tick_params(axis='y', labelcolor=color_gold)
    
    formatter = ScalarFormatter()
    formatter.set_scientific(False) 
    ax1_gold.yaxis.set_major_formatter(formatter)
    ax1_gold.set_yscale('log')
    
    # Create Twin Axis for Bitcoin
    ax1_btc = ax1_gold.twinx() 
    line_btc, = ax1_btc.plot(
        combined.index, 
        combined['Close_BTC'], 
        label="Bitcoin Price (USD per BTC)", 
        color=color_btc, 
        linewidth=2.5
    )
    ax1_btc.set_ylabel("Prices in USD per BTC (Bitcoin)", fontsize=14, color=color_btc)
    ax1_btc.tick_params(axis='y', labelcolor=color_btc)
    
    ax1_btc.yaxis.set_major_formatter(formatter)
    ax1_btc.set_yscale('log')
    
    # Set fixed limits based on the full data range for smoother animation
    ax1_gold.set_xlim(combined.index[0], combined.index[-1])
    ax1_gold.set_ylim(combined['Close_Gold'].min() * 0.9, combined['Close_Gold'].max() * 1.1)
    ax1_btc.set_ylim(combined['Close_BTC'].min() * 0.9, combined['Close_BTC'].max() * 1.1)

    # Title and Legend
    ax1_gold.set_title(
        f"Raw Prices of Gold and Bitcoin (Logarithmic Scale from {START_DATE})", 
        fontsize=16, 
        fontweight='bold', 
        pad=10
    )
    ax1_gold.set_xlabel("Time", fontsize=14)
    
    lines1, labels1 = ax1_gold.get_legend_handles_labels()
    lines2, labels2 = ax1_btc.get_legend_handles_labels()
    ax1_gold.legend(lines1 + lines2, labels1 + labels2, fontsize=10, loc='upper left') 

    # --- Button Implementation ---
    # Define the coordinates for the button: [left, bottom, width, height]
    ax_button = fig.add_axes([0.45, 0.02, 0.15, 0.04]) 
    
    # Create the Button instance
    button = Button(ax_button, 'Start Animation', color='#4CAF50', hovercolor='#66BB6A')
    
    # Connect the button click event to the callback function
    # We pass all necessary objects to the callback
    button.on_clicked(lambda event: start_animation_callback(
        event, combined, fig, ax1_gold, line_gold, line_btc, button
    ))

    # --- Final Output ---
    plt.show()
    
    # 3. Print Statistics to Console (prints after the window is closed)
    print("\n" + "="*50)
    print(f"--- Annualized Statistics ({START_DATE} to Present) ---")
    print("="*50)
    print(f"| Metric                      | Gold       | Bitcoin    |")
    print("-" * 50)
    print(f"| Annualized Mean Return      | {gold_mean:8.2f}% | {btc_mean:8.2f}% |")
    print(f"| Annualized Std Dev (Vol.) | {gold_std:8.2f}% | {btc_std:8.2f}% |")
    print("-" * 50)
    print(f"| Correlation (Gold vs BTC)   | {correlation:18.3f} |")
    print("="*50 + "\n")


if __name__ == "__main__":
    plot_gold_btc_dashboard()

