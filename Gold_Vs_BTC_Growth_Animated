import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation 
from matplotlib.widgets import Button
import os
import numpy as np 
from datetime import datetime
from matplotlib.ticker import ScalarFormatter, FuncFormatter 
from matplotlib import dates
import math 

# --- CONFIGURATION (Change these file paths as needed) ---
# IMPORTANT: Adjust this BASE_PATH to the actual location of your CSV files.
BASE_PATH = "c:/Users/peter_bkbowcp/OneDrive/Desktop/Dashboard Project/" 

GOLD_FILE = BASE_PATH + "Gold Futures Historical Data.csv"
BTC_FILE = BASE_PATH + "Bitcoin Historical Data.csv"

START_DATE = '2011-01-01'
TRADING_DAYS_PER_YEAR = 252

# Animation Configuration
STEP_SIZE = 50 # Days revealed per frame (adjust for speed/smoothness)

# List of common column headers for the closing price
CLOSE_CANDIDATES = ["Close", "Adj Close", "Close*", "Price", "Last", "Close/Last"]

# Global variables for animation and annotation (Matplotlib objects need to be global)
ani = None
annot = None # Global variable to hold the annotation object

# --- Helper function to clean quoted, comma-separated numbers ---
def clean_numeric_series(s):
    """Removes non-numeric characters (quotes, commas) and converts to float."""
    return (s.astype(str)
            .str.replace('"', '', regex=False)
            .str.replace("'", "", regex=False)
            .str.replace(",", "", regex=False)
            .str.strip()
            .replace("", pd.NA) 
            .astype(float)
           )

# --- Helper function to load and clean a single file ---
def load_and_clean(filename, asset_name):
    """Loads a CSV, cleans data, sets Date as index, and converts prices to float."""
    print(f"Loading {asset_name} data from: {filename}")
    if not os.path.exists(filename):
        raise FileNotFoundError(
            f"ERROR: File not found: '{filename}'. "
            f"Please ensure the path and filename is correct."
        )

    df = pd.read_csv(filename, skip_blank_lines=True)
    df.columns = [c.strip() for c in df.columns]

    date_col = next((c for c in df.columns if c.strip().lower() in ["date", "day", "time"]), None)
    if date_col is None:
        raise ValueError(f"No 'Date' column found in {filename}.")
        
    close_col = next(
        (c for c in df.columns for cand in CLOSE_CANDIDATES if c.strip().lower() == cand.strip().lower()), 
        None
    )
    if close_col is None:
        raise ValueError(f"No closing price column found (e.g., Close, Price) in {filename}.")
        
    df["Date"] = pd.to_datetime(
        df[date_col].astype(str).str.replace('"', '').str.strip(), 
        errors='coerce',
        infer_datetime_format=True
    )

    df["Close"] = clean_numeric_series(df[close_col])
    
    df['Daily_Return'] = df['Close'].pct_change()
    
    df = df[["Date", "Close", "Daily_Return"]].dropna(subset=["Date", "Close"]).sort_values("Date")
    df = df.set_index("Date")
    df = df[df.index >= START_DATE]
    
    if not df.empty and df.iloc[0]['Close'] != 0:
        df[f'Index_{asset_name}'] = (df['Close'] / df['Close'].iloc[0]) * 100
    else:
        df[f'Index_{asset_name}'] = 100
    
    return df.rename(columns={'Close': f'Close_{asset_name}', 'Daily_Return': f'Return_{asset_name}'})

# --- Custom Log Formatter ---
def log_formatter(v, pos):
    """Formats tick values for logarithmic scale to show real numbers with commas."""
    # Format integers with commas (or two decimals if less than 1)
    return f"{v:,.0f}" if v >= 1 else f"{v:,.2f}" 

# --- Hover Annotation Functions ---

def update_annot(index, combined, annot):
    """Updates the position and text of the annotation object."""
    # Get values for the closest index
    date = combined.index[index].strftime('%Y-%m-%d')
    gold_price = combined['Close_Gold'].iloc[index]
    btc_price = combined['Close_BTC'].iloc[index]
    
    # x_pos is the Matplotlib numerical date, y_pos is Gold price (used as anchor for placement)
    x_pos = dates.date2num(combined.index[index].to_pydatetime())
    y_pos_gold = gold_price
    
    # Format the text with proper numbers
    text = (f"Date: {date}\n"
            f"Gold: ${gold_price:,.2f}\n" # Format Gold with 2 decimals
            f"BTC: ${btc_price:,.0f}")  # Format BTC with 0 decimals (usually large integers)

    # Update annotation position and text
    annot.xy = (x_pos, y_pos_gold)
    annot.set_text(text)
    
    # Adjust position slightly for better visibility
    annot.get_bbox_patch().set_alpha(0.9)


def hover(event, combined, ax1_gold, date_nums):
    """Callback function for mouse motion event."""
    global annot
    global ani

    # 1. Check if the mouse is over the main plot area
    if event.inaxes != ax1_gold:
        if annot and annot.get_visible():
            annot.set_visible(False)
            ax1_gold.figure.canvas.draw_idle()
        return
        
    # 2. Prevent hover updates during animation
    # Using getattr for a safer check if event_source exists
    is_animating = ani is not None and getattr(ani.event_source, 'running', False)
    if is_animating:
        return 

    xdata_mouse = event.xdata
    
    if xdata_mouse is None:
        # Hide annotation if xdata is null (e.g., hovering over the edge)
        if annot and annot.get_visible():
            annot.set_visible(False)
            ax1_gold.figure.canvas.draw_idle()
        return
        
    # 3. Find the index of the closest data point based on the date (x-axis)
    diff = np.abs(date_nums - xdata_mouse)
    closest_index = np.argmin(diff)
    
    # 4. Define a large proximity threshold (e.g., within 45 days)
    date_unit_threshold = dates.date2num(datetime.now()) - dates.date2num(datetime.now() - pd.Timedelta(days=45))
    
    if diff[closest_index] < date_unit_threshold:
        # Point is close enough, update and show annotation
        update_annot(closest_index, combined, annot)
        annot.set_visible(True)
        ax1_gold.figure.canvas.draw_idle()
    else:
        # Point is too far, hide annotation
        if annot and annot.get_visible():
            annot.set_visible(False)
            ax1_gold.figure.canvas.draw_idle()

# --- Animation/Update Function ---
def animate_frame(i, combined, line_gold, line_btc, ax1_gold, button):
    """Updates the data displayed on the plot for each frame using the frame index 'i'."""
    
    end_index = min((i + 1) * STEP_SIZE, len(combined))
    data_slice = combined.iloc[:end_index]

    if data_slice.empty:
        return line_gold, line_btc

    # Update line data
    line_gold.set_data(data_slice.index, data_slice['Close_Gold'])
    line_btc.set_data(data_slice.index, data_slice['Close_BTC'])

    # Update the title to show the current date of the animation
    current_date = data_slice.index[-1].strftime('%Y-%m-%d')
    current_scale_text = 'Logarithmic Scale' if ax1_gold.get_yscale() == 'log' else 'Linear Scale'
    
    # --- CONSISTENT TITLE ---
    ax1_gold.set_title(
        f"Gold Vs Bitcoin Growth ({current_scale_text}) up to: {current_date}",
        fontsize=16,
        fontweight='bold',
        pad=10
    )
    print(f"Drawing up to: {current_date}", end='\r')

    # Check if this is the final frame and update the button text
    if end_index == len(combined):
        button.label.set_text('Replay Animation')
        button.ax.figure.canvas.draw_idle() 
    
    return line_gold, line_btc

# --- Animation Button Callback Function (Infinitely Replayable) ---
def start_animation_callback(event, combined, fig, ax1_gold, line_gold, line_btc, button):
    """Initializes and starts the FuncAnimation when the button is clicked."""
    global ani
    global annot
    
    # 1. Stop and release any previous animation (FIX FOR RE-PRESS)
    if ani:
        print("Stopping previous animation...")
        try:
            # Check if event_source exists and stop it
            if ani.event_source:
                ani.event_source.stop()
        except:
            pass 
        ani = None 
        
    # Hide the annotation when animation starts
    if annot and annot.get_visible():
        annot.set_visible(False)
    
    # 2. Clear the lines to start from scratch (resets the plot to empty lines)
    line_gold.set_data([], [])
    line_btc.set_data([], [])

    # 3. Update button state and title
    current_scale_text = 'Logarithmic Scale' if ax1_gold.get_yscale() == 'log' else 'Linear Scale'
    button.label.set_text('Animating...')
    button.ax.figure.canvas.draw_idle() 

    # --- CONSISTENT TITLE ---
    ax1_gold.set_title(
        f"Gold Vs Bitcoin Growth ({current_scale_text}) Starting...",
        fontsize=16,
        fontweight='bold',
        pad=10
    )

    # 4. Calculate number of frames needed
    num_frames = math.ceil(len(combined) / STEP_SIZE)
    
    # 5. Initialize and assign the animation object to the global variable
    ani = animation.FuncAnimation(
        fig,
        animate_frame,
        fargs=(combined, line_gold, line_btc, ax1_gold, button),
        frames=num_frames, 
        interval=50, # 50 milliseconds between frames
        blit=False, 
        repeat=False
    )
    
    fig.canvas.draw_idle()

# --- Scale Toggle Button Callback Function (Infinitely Pressable) ---
def toggle_scale_callback(event, ax1_gold, ax1_btc, button, combined):
    """Toggles the y-axes between logarithmic and linear scales."""
    global ani 

    current_scale = ax1_gold.get_yscale()
    
    if current_scale == 'log':
        # Switch to Linear
        ax1_gold.set_yscale('linear')
        ax1_btc.set_yscale('linear')
        new_scale_text = 'Linear Scale'
        button.label.set_text('View Log Scale')
        
        # Explicitly set ScalarFormatter for both axes
        formatter_gold = ScalarFormatter(useOffset=False, useMathText=False)
        formatter_gold.set_scientific(False) 
        ax1_gold.yaxis.set_major_formatter(formatter_gold)
        
        formatter_btc = ScalarFormatter(useOffset=False, useMathText=False)
        formatter_btc.set_scientific(False)
        ax1_btc.yaxis.set_major_formatter(formatter_btc)
        
        # Force Matplotlib to use plain style on the y-axis (crucial for linear scale)
        ax1_gold.ticklabel_format(axis='y', style='plain')
        ax1_btc.ticklabel_format(axis='y', style='plain')
        
    else:
        # Switch to Logarithmic
        ax1_gold.set_yscale('log')
        ax1_btc.set_yscale('log')
        new_scale_text = 'Logarithmic Scale'
        button.label.set_text('View Linear Scale')

        # Use the custom log formatter for real numbers on both axes
        ax1_gold.yaxis.set_major_formatter(FuncFormatter(log_formatter))
        ax1_btc.yaxis.set_major_formatter(FuncFormatter(log_formatter))
        
    # --- FIX: Check if animation is running (safer check) ---
    # This prevents the static plot title from overriding the animated title
    # but still allows the scale change to apply instantly.
    is_animating = ani is not None and getattr(ani.event_source, 'running', False)
    
    # Update the main title only if the animation is NOT running (i.e., static view)
    if not is_animating:
         current_date_str = combined.index[-1].strftime('%Y-%m-%d')
         # --- CONSISTENT TITLE ---
         ax1_gold.set_title(
            f"Gold Vs Bitcoin Growth ({new_scale_text} up to: {current_date_str})", 
            fontsize=16, 
            fontweight='bold', 
            pad=10
        )

    # Redraw the figure to apply the scale and formatter changes
    # This call is CRUCIAL for updating the view when the animation is off.
    ax1_gold.figure.canvas.draw_idle()


# --- Main Plotting Function ---
def plot_gold_btc_dashboard():
    global annot 
    
    try:
        # Load Gold and BTC files
        gold_df = load_and_clean(GOLD_FILE, 'Gold')
        btc_df  = load_and_clean(BTC_FILE, 'BTC')
            
    except Exception as e:
        print(f"An error occurred during file loading: {e}")
        return

    # 1. Merge data
    combined = pd.merge(gold_df[[f'Close_Gold', 'Return_Gold']], 
                        btc_df[[f'Close_BTC', 'Return_BTC']], 
                        left_index=True, right_index=True, how="inner").dropna()
        
    if combined.empty:
        print(f"ERROR: No common dates found across the required files after {START_DATE}.")
        return
        
    # --- Data Preparation for Hover ---
    date_nums = dates.date2num(combined.index.to_numpy())
        
    # 2. Calculate Statistics (Unchanged)
    daily_returns = combined[['Return_Gold', 'Return_BTC']].dropna()
    
    gold_mean = daily_returns["Return_Gold"].mean() * TRADING_DAYS_PER_YEAR * 100
    gold_std  = daily_returns["Return_Gold"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    btc_mean  = daily_returns["Return_BTC"].mean() * TRADING_DAYS_PER_YEAR * 100
    btc_std   = daily_returns["Return_BTC"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    correlation = daily_returns["Return_Gold"].corr(daily_returns["Return_BTC"])
    
    # --- Plotting Setup ---
    plt.style.use('default')
    
    fig, ax1_gold = plt.subplots(1, 1, figsize=(18, 9)) 
    fig.subplots_adjust(bottom=0.12)

    color_gold = '#E69F00' 
    color_btc = '#003366' 

    # --- Initial Static Plot (Starts in Logarithmic Scale) ---
    
    # Plot Gold Price (Orange, Left Axis)
    line_gold, = ax1_gold.plot(
        combined.index, 
        combined['Close_Gold'], 
        label="Gold Price (USD per oz)", 
        color=color_gold, 
        linewidth=2.5
    )
    ax1_gold.set_ylabel("Prices in USD per oz (Gold)", fontsize=16, color=color_gold)
    ax1_gold.tick_params(axis='y', labelcolor=color_gold)
    
    # Apply Logarithmic Scale initially
    ax1_gold.set_yscale('log')
    ax1_gold.yaxis.set_major_formatter(FuncFormatter(log_formatter))
    
    # Create Twin Axis for Bitcoin
    ax1_btc = ax1_gold.twinx() 
    line_btc, = ax1_btc.plot(
        combined.index, 
        combined['Close_BTC'], 
        label="Bitcoin Price (USD per BTC)", 
        color=color_btc, 
        linewidth=2.5
    )
    ax1_btc.set_ylabel("Prices in USD per BTC (Bitcoin)", fontsize=16, color=color_btc)
    ax1_btc.tick_params(axis='y', labelcolor=color_btc)
    
    # Apply Logarithmic Scale initially
    ax1_btc.set_yscale('log')
    ax1_btc.yaxis.set_major_formatter(FuncFormatter(log_formatter))
    
    # Set fixed limits based on the full data range for smoother animation
    ax1_gold.set_xlim(combined.index[0], combined.index[-1])
    ax1_gold.set_ylim(combined['Close_Gold'].min() * 0.9, combined['Close_Gold'].max() * 1.1)
    ax1_btc.set_ylim(combined['Close_BTC'].min() * 0.9, combined['Close_BTC'].max() * 1.1)

    # Title and Legend
    current_date_str = combined.index[-1].strftime('%Y-%m-%d')
    ax1_gold.set_title(
        f"Gold Vs Bitcoin Growth (Logarithmic Scale)", 
        fontsize=16, 
        fontweight='bold', 
        pad=10
    )
    ax1_gold.set_xlabel("Time", fontsize=14)
    
    lines1, labels1 = ax1_gold.get_legend_handles_labels()
    lines2, labels2 = ax1_btc.get_legend_handles_labels()
    ax1_gold.legend(lines1 + lines2, labels1 + labels2, fontsize=10, loc='upper left') 

    # ------------------------------------------------------------------
    # --- Hover Annotation Initialization ---
    # ------------------------------------------------------------------
    annot = ax1_gold.annotate(
        "", 
        xy=(0,0), # Placeholder coordinates
        xytext=(20, 20), # Offset text from the data point
        textcoords="offset points",
        bbox=dict(boxstyle="round,pad=0.5", fc="white", alpha=0.9, ec="black"),
        arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=0.1", color="black"),
        ha='left'
    )
    annot.set_visible(False)
    
    fig.canvas.mpl_connect("motion_notify_event", 
                           lambda event: hover(event, combined, ax1_gold, date_nums))
                           
    # ------------------------------------------------------------------
    # --- Button Implementation ---
    # ------------------------------------------------------------------

    # 1. Animation Button (Green, Left Position)
    ax_anim_button = fig.add_axes([0.35, 0.04, 0.18, 0.04]) 
    button_anim = Button(ax_anim_button, 'Start Animation', color='#4CAF50', hovercolor='#66BB6A')
    
    button_anim.on_clicked(lambda event: start_animation_callback(
        event, combined, fig, ax1_gold, line_gold, line_btc, button_anim
    ))
    
    # 2. Scale Toggle Button (Blue, Right Position)
    ax_scale_button = fig.add_axes([0.57, 0.04, 0.18, 0.04]) 
    button_scale = Button(ax_scale_button, 'View Linear Scale', color='#2196F3', hovercolor='#4DAAF8')
    
    # Connect the toggle callback
    button_scale.on_clicked(lambda event: toggle_scale_callback(
        event, ax1_gold, ax1_btc, button_scale, combined
    ))
    
    # --- Final Output ---
    plt.show()
    
    # 3. Print Statistics to Console (prints after the window is closed)
    print("\n" + "="*50)
    print(f"--- Annualized Statistics ({START_DATE} to Present) ---")
    print("="*50)
    print(f"| Metric                      | Gold       | Bitcoin    |")
    print("-" * 50)
    print(f"| Annualized Mean Return      | {gold_mean:8.2f}% | {btc_mean:8.2f}% |")
    print(f"| Annualized Std Dev (Vol.) | {gold_std:8.2f}% | {btc_std:8.2f}% |")
    print("-" * 50)
    print(f"| Correlation (Gold vs BTC)   | {correlation:18.3f} |")
    print("="*50 + "\n")


if __name__ == "__main__":
    plot_gold_btc_dashboard()

