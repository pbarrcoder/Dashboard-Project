import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation 
from matplotlib.widgets import Button
import os
import numpy as np 
from datetime import datetime
from matplotlib.ticker import ScalarFormatter, FuncFormatter 
import math 

# --- CONFIGURATION (Change these file paths as needed) ---
# NOTE: Using absolute paths to prevent File Not Found errors.
# IMPORTANT: Adjust this BASE_PATH to the actual location of your CSV files.
BASE_PATH = "c:/Users/peter_bkbowcp/OneDrive/Desktop/Dashboard Project/" 

GOLD_FILE = BASE_PATH + "Gold Futures Historical Data.csv"
BTC_FILE = BASE_PATH + "Bitcoin Historical Data.csv"

START_DATE = '2011-01-01'
TRADING_DAYS_PER_YEAR = 252

# Animation Configuration
# Retained the faster animation speed (50 days per frame)
STEP_SIZE = 50 # Days revealed per frame (adjust for speed/smoothness)

# List of common column headers for the closing price
CLOSE_CANDIDATES = ["Close", "Adj Close", "Close*", "Price", "Last", "Close/Last"]

# Global variable to hold the animation object (must be global to prevent garbage collection)
ani = None

# --- Helper function to clean quoted, comma-separated numbers ---
def clean_numeric_series(s):
    """Removes non-numeric characters (quotes, commas) and converts to float."""
    return (s.astype(str)
            .str.replace('"', '', regex=False)
            .str.replace("'", "", regex=False)
            .str.replace(",", "", regex=False)
            .str.strip()
            .replace("", pd.NA) 
            .astype(float)
           )

# --- Helper function to load and clean a single file ---
def load_and_clean(filename, asset_name):
    """Loads a CSV, cleans data, sets Date as index, and converts prices to float."""
    print(f"Loading {asset_name} data from: {filename}")
    if not os.path.exists(filename):
        raise FileNotFoundError(
            f"ERROR: File not found: '{filename}'. "
            f"Please ensure the path and filename are correct."
        )

    df = pd.read_csv(filename, skip_blank_lines=True)
    df.columns = [c.strip() for c in df.columns]

    date_col = next((c for c in df.columns if c.strip().lower() in ["date", "day", "time"]), None)
    if date_col is None:
        raise ValueError(f"No 'Date' column found in {filename}.")
        
    close_col = next(
        (c for c in df.columns for cand in CLOSE_CANDIDATES if c.strip().lower() == cand.strip().lower()), 
        None
    )
    if close_col is None:
        raise ValueError(f"No closing price column found (e.g., Close, Price) in {filename}.")
        
    df["Date"] = pd.to_datetime(
        df[date_col].astype(str).str.replace('"', '').str.strip(), 
        errors='coerce',
        infer_datetime_format=True
    )

    df["Close"] = clean_numeric_series(df[close_col])
    
    df['Daily_Return'] = df['Close'].pct_change()
    
    df = df[["Date", "Close", "Daily_Return"]].dropna(subset=["Date", "Close"]).sort_values("Date")
    df = df.set_index("Date")
    df = df[df.index >= START_DATE]
    
    if not df.empty and df.iloc[0]['Close'] != 0:
        df[f'Index_{asset_name}'] = (df['Close'] / df['Close'].iloc[0]) * 100
    else:
        df[f'Index_{asset_name}'] = 100
    
    return df.rename(columns={'Close': f'Close_{asset_name}', 'Daily_Return': f'Return_{asset_name}'})

# --- Custom Log Formatter ---
def log_formatter(v, pos):
    """Formats tick values for logarithmic scale to show real numbers with commas (used for BTC and Gold)."""
    # Formats the tick value (v) without scientific notation, adding commas for large numbers
    return f"{v:,.0f}" if v >= 1 else f"{v:,.2f}" # Format integers with commas

# --- Animation/Update Function ---
def animate_frame(i, combined, line_gold, line_btc, ax1_gold, button):
    """Updates the data displayed on the plot for each frame using the frame index 'i'."""
    
    # Calculate the end index for the current frame: (frame_number + 1) * step_size
    end_index = min((i + 1) * STEP_SIZE, len(combined))

    # Slice the data up to the current frame's end index
    data_slice = combined.iloc[:end_index]

    if data_slice.empty:
        return line_gold, line_btc

    # Update Gold line data
    line_gold.set_data(data_slice.index, data_slice['Close_Gold'])
    # Update BTC line data
    line_btc.set_data(data_slice.index, data_slice['Close_BTC'])

    # Update the title to show the current date of the animation
    current_date = data_slice.index[-1].strftime('%Y-%m-%d')
    current_scale_text = 'Logarithmic Scale' if ax1_gold.get_yscale() == 'log' else 'Linear Scale'
    
    # --- UPDATED TITLE ---
    ax1_gold.set_title(
        f"Gold Vs Bitcoin Growth ({current_scale_text}) up to: {current_date}",
        fontsize=16,
        fontweight='bold',
        pad=10
    )
    # Print current date to the console for tracking
    print(f"Drawing up to: {current_date}", end='\r')

    # Check if this is the final frame and update the button text
    if end_index == len(combined):
        button.label.set_text('Replay Animation')
        # Ensure the button text updates immediately
        button.ax.figure.canvas.draw_idle() 
    
    # Return the artists (lines) that were modified
    return line_gold, line_btc

# --- Animation Button Callback Function ---
def start_animation_callback(event, combined, fig, ax1_gold, line_gold, line_btc, button):
    """Initializes and starts the FuncAnimation when the button is clicked."""
    global ani
    
    # 1. Stop any previous animation
    if ani:
        ani.event_source.stop()
    
    # 2. Clear the lines to start from scratch (resets the plot to empty lines)
    line_gold.set_data([], [])
    line_btc.set_data([], [])

    # 3. Update button state and title
    current_scale_text = 'Logarithmic Scale' if ax1_gold.get_yscale() == 'log' else 'Linear Scale'
    button.label.set_text('Animating...')
    button.ax.figure.canvas.draw_idle() # Redraw button immediately

    # --- UPDATED TITLE ---
    ax1_gold.set_title(
        f"Gold Vs Bitcoin Growth ({current_scale_text}) Starting...",
        fontsize=16,
        fontweight='bold',
        pad=10
    )

    # 4. Calculate number of frames needed
    num_frames = math.ceil(len(combined) / STEP_SIZE)
    
    # 5. Initialize and assign the animation object to the global variable
    ani = animation.FuncAnimation(
        fig,
        animate_frame,
        fargs=(combined, line_gold, line_btc, ax1_gold, button),
        frames=num_frames, 
        interval=50, # 50 milliseconds between frames
        blit=False, 
        repeat=False
    )
    
    # Ensure the plot redrawing is triggered
    fig.canvas.draw_idle()

# --- Scale Toggle Button Callback Function (FIXED) ---
def toggle_scale_callback(event, ax1_gold, ax1_btc, button):
    """Toggles the y-axes between logarithmic and linear scales."""
    global ani 

    current_scale = ax1_gold.get_yscale()
    
    if current_scale == 'log':
        # Switch to Linear
        ax1_gold.set_yscale('linear')
        ax1_btc.set_yscale('linear')
        new_scale_text = 'Linear Scale'
        button.label.set_text('View Log Scale')
        
        # Explicitly set ScalarFormatter for both axes
        formatter_gold = ScalarFormatter(useOffset=False, useMathText=False)
        formatter_gold.set_scientific(False) 
        ax1_gold.yaxis.set_major_formatter(formatter_gold)
        
        formatter_btc = ScalarFormatter(useOffset=False, useMathText=False)
        formatter_btc.set_scientific(False)
        ax1_btc.yaxis.set_major_formatter(formatter_btc)
        
        # --- SCIENTIFIC NOTATION FIX ---
        # Force Matplotlib to use plain style on the y-axis (crucial for linear scale)
        ax1_gold.ticklabel_format(axis='y', style='plain')
        ax1_btc.ticklabel_format(axis='y', style='plain')
        
    else:
        # Switch to Logarithmic
        ax1_gold.set_yscale('log')
        ax1_btc.set_yscale('log')
        new_scale_text = 'Logarithmic Scale'
        button.label.set_text('View Linear Scale')

        # Use the custom log formatter for real numbers on both axes
        ax1_gold.yaxis.set_major_formatter(FuncFormatter(log_formatter))
        ax1_btc.yaxis.set_major_formatter(FuncFormatter(log_formatter))
        
    # Update the main title to reflect the new scale
    if ani is None or not ani.event_source.running:
         # --- UPDATED TITLE ---
         ax1_gold.set_title(
            f"Gold Vs Bitcoin Growth ({new_scale_text} from {START_DATE})", 
            fontsize=16, 
            fontweight='bold', 
            pad=10
        )

    # Redraw the figure to apply the scale and formatter changes
    ax1_gold.figure.canvas.draw_idle()


# --- Main Plotting Function ---
def plot_gold_btc_dashboard():
    
    try:
        # Load Gold and BTC files
        gold_df = load_and_clean(GOLD_FILE, 'Gold')
        btc_df  = load_and_clean(BTC_FILE, 'BTC')
            
    except Exception as e:
        print(f"An error occurred during file loading: {e}")
        return

    # 1. Merge data
    combined = pd.merge(gold_df[[f'Close_Gold', 'Return_Gold']], 
                        btc_df[[f'Close_BTC', 'Return_BTC']], 
                        left_index=True, right_index=True, how="inner").dropna()
        
    if combined.empty:
        print(f"ERROR: No common dates found across the required files after {START_DATE}.")
        return
        
    # 2. Calculate Statistics
    daily_returns = combined[['Return_Gold', 'Return_BTC']].dropna()
    
    gold_mean = daily_returns["Return_Gold"].mean() * TRADING_DAYS_PER_YEAR * 100
    gold_std  = daily_returns["Return_Gold"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    btc_mean  = daily_returns["Return_BTC"].mean() * TRADING_DAYS_PER_YEAR * 100
    btc_std   = daily_returns["Return_BTC"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    correlation = daily_returns["Return_Gold"].corr(daily_returns["Return_BTC"])
    
    # --- Plotting Setup ---
    plt.style.use('default')
    
    # Create the main axes for the plot
    fig, ax1_gold = plt.subplots(1, 1, figsize=(18, 9)) 
    
    # Adjust subplot position to make room for the two buttons and prevent label conflict
    fig.subplots_adjust(bottom=0.12)

    # Define colors
    color_gold = '#E69F00' 
    color_btc = '#003366' 

    # --- Initial Static Plot (Starts in Logarithmic Scale) ---
    
    # Plot Gold Price (Orange, Left Axis)
    line_gold, = ax1_gold.plot(
        combined.index, 
        combined['Close_Gold'], 
        label="Gold Price (USD per oz)", 
        color=color_gold, 
        linewidth=2.5
    )
    ax1_gold.set_ylabel("Prices in USD per oz (Gold)", fontsize=14, color=color_gold)
    ax1_gold.tick_params(axis='y', labelcolor=color_gold)
    
    # Apply Logarithmic Scale initially
    ax1_gold.set_yscale('log')
    
    # Apply FuncFormatter to Gold Y-Axis for real numbers
    ax1_gold.yaxis.set_major_formatter(FuncFormatter(log_formatter))
    
    # Create Twin Axis for Bitcoin
    ax1_btc = ax1_gold.twinx() 
    line_btc, = ax1_btc.plot(
        combined.index, 
        combined['Close_BTC'], 
        label="Bitcoin Price (USD per BTC)", 
        color=color_btc, 
        linewidth=2.5
    )
    ax1_btc.set_ylabel("Prices in USD per BTC (Bitcoin)", fontsize=14, color=color_btc)
    ax1_btc.tick_params(axis='y', labelcolor=color_btc)
    
    # Apply Logarithmic Scale initially
    ax1_btc.set_yscale('log')
    
    # Apply FuncFormatter to Bitcoin Y-Axis for real numbers
    ax1_btc.yaxis.set_major_formatter(FuncFormatter(log_formatter))
    
    # Set fixed limits based on the full data range for smoother animation
    ax1_gold.set_xlim(combined.index[0], combined.index[-1])
    ax1_gold.set_ylim(combined['Close_Gold'].min() * 0.9, combined['Close_Gold'].max() * 1.1)
    ax1_btc.set_ylim(combined['Close_BTC'].min() * 0.9, combined['Close_BTC'].max() * 1.1)

    # Title and Legend
    # --- UPDATED INITIAL STATIC TITLE ---
    ax1_gold.set_title(
        f"Gold Vs Bitcoin Growth (Logarithmic Scale from {START_DATE})", 
        fontsize=16, 
        fontweight='bold', 
        pad=10
    )
    ax1_gold.set_xlabel("Time", fontsize=14)
    
    lines1, labels1 = ax1_gold.get_legend_handles_labels()
    lines2, labels2 = ax1_btc.get_legend_handles_labels()
    ax1_gold.legend(lines1 + lines2, labels1 + labels2, fontsize=10, loc='upper left') 

    # ------------------------------------------------------------------
    # --- Button Implementation ---
    # ------------------------------------------------------------------

    # 1. Animation Button (Green, Left Position)
    # Coordinates: [left, bottom, width, height]
    ax_anim_button = fig.add_axes([0.35, 0.04, 0.18, 0.04]) 
    button_anim = Button(ax_anim_button, 'Start Animation', color='#4CAF50', hovercolor='#66BB6A')
    
    # Connect the animation callback
    button_anim.on_clicked(lambda event: start_animation_callback(
        event, combined, fig, ax1_gold, line_gold, line_btc, button_anim
    ))
    
    # 2. Scale Toggle Button (Blue, Right Position)
    ax_scale_button = fig.add_axes([0.57, 0.04, 0.18, 0.04]) 
    
    # Initial scale is 'log', so button prompts user to switch to 'linear'
    button_scale = Button(ax_scale_button, 'View Linear Scale', color='#2196F3', hovercolor='#4DAAF8')
    
    # Connect the toggle callback
    button_scale.on_clicked(lambda event: toggle_scale_callback(
        event, ax1_gold, ax1_btc, button_scale
    ))
    
    # --- Final Output ---
    plt.show()
    
    # 3. Print Statistics to Console (prints after the window is closed)
    print("\n" + "="*50)
    print(f"--- Annualized Statistics ({START_DATE} to Present) ---")
    print("="*50)
    print(f"| Metric                      | Gold       | Bitcoin    |")
    print("-" * 50)
    print(f"| Annualized Mean Return      | {gold_mean:8.2f}% | {btc_mean:8.2f}% |")
    print(f"| Annualized Std Dev (Vol.) | {gold_std:8.2f}% | {btc_std:8.2f}% |")
    print("-" * 50)
    print(f"| Correlation (Gold vs BTC)   | {correlation:18.3f} |")
    print("="*50 + "\n")


if __name__ == "__main__":
    plot_gold_btc_dashboard()
