import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation # NEW: Import for animation
import os
import numpy as np 
from datetime import datetime
from matplotlib.ticker import ScalarFormatter
import math # Needed for np.ceil

# --- CONFIGURATION (Change these file paths as needed) ---
# NOTE: Using absolute paths to prevent File Not Found errors.
BASE_PATH = "c:/Users/peter_bkbowcp/OneDrive/Desktop/Dashboard Project/" 

GOLD_FILE = BASE_PATH + "Gold Futures Historical Data.csv"
BTC_FILE = BASE_PATH + "Bitcoin Historical Data.csv"

START_DATE = '2011-01-01' # Starting date for the analysis
TRADING_DAYS_PER_YEAR = 252 # Used for annualizing returns/volatility

# NEW: Animation Configuration
STEP_SIZE = 20 # Number of trading days to reveal per frame (adjust for speed/smoothness)

# List of common column headers for the closing price
CLOSE_CANDIDATES = ["Close", "Adj Close", "Close*", "Price", "Last", "Close/Last"]

# --- Helper function to clean quoted, comma-separated numbers ---
def clean_numeric_series(s):
    """Removes non-numeric characters (quotes, commas) and converts to float."""
    return (s.astype(str)
            .str.replace('"', '', regex=False)
            .str.replace("'", "", regex=False)
            .str.replace(",", "", regex=False)
            .str.strip()
            .replace("", pd.NA) # Replace empty strings with NA
            .astype(float)
           )

# --- Helper function to load and clean a single file ---
def load_and_clean(filename, asset_name):
    """Loads a CSV, cleans data, sets Date as index, and converts prices to float."""
    print(f"Loading {asset_name} data from: {filename}")
    if not os.path.exists(filename):
        # Raise a more descriptive error based on the absolute path
        raise FileNotFoundError(
            f"ERROR: File not found: '{filename}'. "
            f"Please ensure the path and filename are correct."
        )

    df = pd.read_csv(filename, skip_blank_lines=True)
    df.columns = [c.strip() for c in df.columns]

    date_col = next((c for c in df.columns if c.strip().lower() in ["date", "day", "time"]), None)
    if date_col is None:
        raise ValueError(f"No 'Date' column found in {filename}.")
        
    close_col = next(
        (c for c in df.columns for cand in CLOSE_CANDIDATES if c.strip().lower() == cand.strip().lower()), 
        None
    )
    if close_col is None:
        raise ValueError(f"No closing price column found (e.g., Close, Price) in {filename}.")
        
    df["Date"] = pd.to_datetime(
        df[date_col].astype(str).str.replace('"', '').str.strip(), 
        errors='coerce',
        infer_datetime_format=True
    )

    df["Close"] = clean_numeric_series(df[close_col])
    
    # Calculate daily returns for statistics later
    df['Daily_Return'] = df['Close'].pct_change()
    
    # Set Date as index for time series calculations and filter by START_DATE
    df = df[["Date", "Close", "Daily_Return"]].dropna(subset=["Date", "Close"]).sort_values("Date")
    df = df.set_index("Date")
    df = df[df.index >= START_DATE]
    
    # Calculate Cumulative Return Index (100 at start) - not used in this plot, but good for reference
    if not df.empty and df.iloc[0]['Close'] != 0:
        df[f'Index_{asset_name}'] = (df['Close'] / df['Close'].iloc[0]) * 100
    else:
        df[f'Index_{asset_name}'] = 100
    
    return df.rename(columns={'Close': f'Close_{asset_name}', 'Daily_Return': f'Return_{asset_name}'})

# --- Animation Setup ---

def init_plot(ax1_gold, ax1_btc, combined):
    """Initializes the plot elements and sets fixed limits for smooth animation."""
    # Define colors
    color_gold = '#E69F00' # Gold/Orange
    color_btc = '#003366' # Dark Navy Blue

    # Set up axes and plot empty lines
    ax1_gold.set_ylabel("Prices in USD per oz (Gold)", fontsize=14, color=color_gold)
    ax1_gold.tick_params(axis='y', labelcolor=color_gold)
    ax1_btc.set_ylabel("Prices in USD per BTC (Bitcoin)", fontsize=14, color=color_btc)
    ax1_btc.tick_params(axis='y', labelcolor=color_btc)

    # Apply ScalarFormatter and Log Scale
    formatter = ScalarFormatter()
    formatter.set_scientific(False)
    ax1_gold.yaxis.set_major_formatter(formatter)
    ax1_btc.yaxis.set_major_formatter(formatter)
    ax1_gold.set_yscale('log')
    ax1_btc.set_yscale('log')

    # Set fixed limits based on the full data range for smoother animation
    ax1_gold.set_xlim(combined.index[0], combined.index[-1])
    ax1_gold.set_ylim(combined['Close_Gold'].min() * 0.9, combined['Close_Gold'].max() * 1.1)
    ax1_btc.set_ylim(combined['Close_BTC'].min() * 0.9, combined['Close_BTC'].max() * 1.1)

    # Initialize empty lines for animation
    line_gold, = ax1_gold.plot([], [], label="Gold Price (USD per oz)", color=color_gold, linewidth=2.5)
    line_btc, = ax1_btc.plot([], [], label="Bitcoin Price (USD per BTC)", color=color_btc, linewidth=2.5)

    ax1_gold.set_title(
        f"Animated Price Growth of Gold and Bitcoin (Logarithmic Scale from {START_DATE})",
        fontsize=16,
        fontweight='bold',
        pad=10
    )
    ax1_gold.set_xlabel("Time", fontsize=14)

    # Combine and display legends
    lines1, labels1 = ax1_gold.get_legend_handles_labels()
    lines2, labels2 = ax1_btc.get_legend_handles_labels()
    ax1_gold.legend(lines1 + lines2, labels1 + labels2, fontsize=10, loc='upper left')

    # Return the line objects, which FuncAnimation will update
    return line_gold, line_btc

# This list will hold the line objects returned by init_plot
lines = [] 
# This variable will track the index of the last data point drawn
current_data_index = 0

def animate_frame(i, combined, line_gold, line_btc, ax1_gold):
    """Updates the data displayed on the plot for each frame."""
    global current_data_index
    
    # Calculate the end index for the current frame
    end_index = min((i + 1) * STEP_SIZE, len(combined))

    if end_index == current_data_index:
        # If we haven't moved forward, no need to update
        return line_gold, line_btc # Must return blitted artists

    current_data_index = end_index
    data_slice = combined.iloc[:current_data_index]

    if data_slice.empty:
        return line_gold, line_btc

    # Update Gold line data
    line_gold.set_data(data_slice.index, data_slice['Close_Gold'])
    # Update BTC line data
    line_btc.set_data(data_slice.index, data_slice['Close_BTC'])

    # Update the title to show the current date of the animation
    current_date = data_slice.index[-1].strftime('%Y-%m-%d')
    ax1_gold.set_title(
        f"Animated Price Growth of Gold and Bitcoin (Data up to: {current_date})",
        fontsize=16,
        fontweight='bold',
        pad=10
    )

    # Return the artists (lines) that were modified
    return line_gold, line_btc


# --- Main Execution Block ---
if __name__ == "__main__":
    
    # 1. Load and Clean Data
    try:
        gold_df = load_and_clean(GOLD_FILE, 'Gold')
        btc_df  = load_and_clean(BTC_FILE, 'BTC')

    except Exception as e:
        print(f"An error occurred during file loading: {e}")
        exit()

    # 2. Merge data on common dates
    combined = pd.merge(gold_df[[f'Close_Gold', 'Return_Gold']],
                        btc_df[[f'Close_BTC', 'Return_BTC']],
                        left_index=True, right_index=True, how="inner").dropna()

    if combined.empty:
        print(f"ERROR: No common dates found across the required files after {START_DATE}.")
        exit()

    # 3. Plotting Setup
    plt.style.use('default')
    # Increased figure width slightly to better match aspect ratio
    fig, ax1_gold = plt.subplots(1, 1, figsize=(18, 8)) 
    ax1_btc = ax1_gold.twinx()

    # Initialize plot elements and get line objects
    line_gold, line_btc = init_plot(ax1_gold, ax1_btc, combined)

    # Calculate number of frames needed
    num_frames = math.ceil(len(combined) / STEP_SIZE)

    # 4. Create and Show the Animation
    # interval=50ms means a new frame every 50 milliseconds (~20 frames per second)
    ani = animation.FuncAnimation(
        fig,
        animate_frame,
        fargs=(combined, line_gold, line_btc, ax1_gold),
        frames=num_frames,
        interval=50,
        blit=True, # Optimized drawing for faster performance
        repeat=False
    )

    plt.tight_layout()
    # Note: The animation window will open and block execution until you close it.
    plt.show() 

    # 5. Calculate and Print Statistics (This will execute after the animation window is closed)
    daily_returns = combined[['Return_Gold', 'Return_BTC']].dropna()

    gold_mean = daily_returns["Return_Gold"].mean() * TRADING_DAYS_PER_YEAR * 100
    gold_std  = daily_returns["Return_Gold"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    btc_mean  = daily_returns["Return_BTC"].mean() * TRADING_DAYS_PER_YEAR * 100
    btc_std   = daily_returns["Return_BTC"].std() * np.sqrt(TRADING_DAYS_PER_YEAR) * 100
    correlation = daily_returns["Return_Gold"].corr(daily_returns["Return_BTC"])

    print("\n" + "="*50)
    print(f"--- Annualized Statistics ({START_DATE} to Present) ---")
    print("="*50)
    print(f"| Metric                      | Gold       | Bitcoin    |")
    print("-" * 50)
    print(f"| Annualized Mean Return      | {gold_mean:8.2f}% | {btc_mean:8.2f}% |")
    print(f"| Annualized Std Dev (Vol.) | {gold_std:8.2f}% | {btc_std:8.2f}% |")
    print("-" * 50)
    print(f"| Correlation (Gold vs BTC)   | {correlation:18.3f} |")
    print("="*50 + "\n")
